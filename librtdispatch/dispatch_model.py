# -*- coding: utf-8 -*-
"""
Pyomo real-time dispatch model

"""
#import pyomo
import pyomo.environ as pe


class RealTimeDispatchModel(object):
    def __init__(self):
        self.model = pe.ConcreteModel()
        self.generateParams({"num_periods":4})
        self.generateVariables()

    def generateParams(self,param_dict):
        ### Sets and Indices ###
        self.model.T = pe.Set(initialize = range(1,param_dict["num_periods"]+1))  #T: time periods
        ### Time-series CSP Parameters ##
        self.model.delta_rs = pe.Param(self.model.T, mutable=True, initialize=0) # \delta^{rs}_{t}: Estimated fraction of period $t$ required for receiver start-up [-]
        self.model.D = pe.Param(self.model.T, mutable=True, initialize=0) #D_{t}: Time-weighted discount factor in period $t$ [-]
        self.model.eta_amb = pe.Param(self.model.T, mutable=True, initialize=0)  #\eta^{amb}_{t}: Cycle efficiency ambient temperature adjustment factor in period $t$ [-]
        self.model.eta_c = pe.Param(self.model.T, mutable=True, initialize=0)   #\eta^{c}_{t}:   Normalized condenser parasitic loss in period $t$ [-] 
        self.model.P = pe.Param(self.model.T, mutable=True, initialize=0)       #P_{t}: Electricity sales price in period $t$ [\$/kWh\sse]
        self.model.Q_in = pe.Param(self.model.T, mutable=True, initialize=0)    #Q^{in}_{t}: Available thermal power generated by the CSP heliostat field in period $t$ [kW\sst]
        self.model.Q_c = pe.Param(self.model.T, mutable=True, initialize=0)     #Q^{c}_{t}: Allowable power per period for cycle start-up in period $t$ [kW\sst]
        self.model.W_dot_net = pe.Param(self.model.T, mutable=True, initialize=0)  #\dot{W}^{net}_{t}: Net grid transmission upper limit in period $t$ [kW\sse]
        self.model.W_u_plus = pe.Param(self.model.T, mutable=True, initialize=0)  #W^{u+}_{t}: Maximum power production when starting generation in period $t$  [kW\sse]
        self.model.W_u_minus = pe.Param(self.model.T, mutable=True, initialize=0)  #W^{u-}_{t}: Maximum power production in period $t$ when stopping generation in period $t+1$  [kW\sse]
        ### Time-Series PV Parameters ###
        #self.model.w_pv = pe.Param(self.model.T, mutable=True, initialize=0)      #w^{PV}_t: <aximum DC power production from PV system in period $t$
        ###  Cost Parameters ###
        self.model.alpha = pe.Param(mutable=True, initialize=0)        #alpha: Conversion factor between unitless and monetary values [\$]
        self.model.Crec = pe.Param(mutable=True, initialize=0)         #Crec: Operating cost of heliostat field and receiver [\$/kWh\sst]
        self.model.Crsu = pe.Param(mutable=True, initialize=0)         #Crsu: Penalty for receiver cold start-up [\$/start]
        self.model.Crhsp = pe.Param(mutable=True, initialize=0)        #Crhsp: Penalty for receiver hot start-up [\$/start]
        self.model.Cpc = pe.Param(mutable=True, initialize=0)          #Cpc: Operating cost of power cycle [\$/kWh\sse]
        self.model.Ccsu = pe.Param(mutable=True, initialize=0)        #Ccsu: Penalty for power cycle cold start-up [\$/start]
        self.model.Cchsp = pe.Param(mutable=True, initialize=0)       #Cchsp: Penalty for power cycle hot start-up [\$/start]
        self.model.C_delta_w = pe.Param(mutable=True, initialize=0)    #C_delta_w: Penalty for change in power cycle  production [\$/$\Delta\text{kW}$\sse]
        self.model.C_v_w = pe.Param(mutable=True, initialize=0)        #C_v_w: Penalty for change in power cycle  production \tcb{beyond designed limits} [\$/$\Delta\text{kW}$\sse]
        self.model.Ccsb = pe.Param(mutable=True, initialize=0)         #Ccsb: Operating cost of power cycle standby operation [\$/kWh\sst]
        ### PV and Battery Parameters ###
        # -------PV and Battery Cost Parameters -------
        #self.model.Cpv = pe.Param(mutable=True, initialize=0)    #Operating cost of photovoltaic field [\$/kWh\sse]
        #self.model.Cbc = pe.Param(mutable=True, initialize=0)    #Operating cost of charging battery [\$/kWh\sse]
        #self.model.Cbd = pe.Param(mutable=True, initialize=0)    #Operating cost of discharging battery [\$/kWh\sse]
        #self.model.Cbl = pe.Param(mutable=True, initialize=0)    #Lifecycle cost for battery [\$/lifecycle]
        ### CSP Field and Receiver Parameters ###
        self.model.deltal = pe.Param(mutable=True, initialize=0)    #Minimum time to start the receiver [hr]
        self.model.Ehs = pe.Param(mutable=True, initialize=0)       #Heliostat field startup or shut down parasitic loss [kWh\sse]
        self.model.Er = pe.Param(mutable=True, initialize=0)        #Required energy expended to start receiver [kWh\sst]
        self.model.Eu = pe.Param(mutable=True, initialize=0)        #Thermal energy storage capacity [kWh\sst]
        self.model.Lr = pe.Param(mutable=True, initialize=0)        #Receiver pumping power per unit power produced [kW\sse/kW\sst]
        self.model.Qrl = pe.Param(mutable=True, initialize=0)       #Minimum operational thermal power delivered by receiver [kWh\sst]
        self.model.Qrsb = pe.Param(mutable=True, initialize=0)      #Required thermal power for receiver standby [kWh\sst]
        self.model.Qrsd = pe.Param(mutable=True, initialize=0)      #Required thermal power for receiver shut down [kWh\sst] 
        self.model.Qru = pe.Param(mutable=True, initialize=0)       #Allowable power per period for receiver start-up [kWh\sst]
        self.model.Wh = pe.Param(mutable=True, initialize=0)        #Heliostat field tracking parasitic loss [kW\sse]
        self.model.Wht = pe.Param(mutable=True, initialize=0)       #[az] this isn't in the implementation.  Tower piping heat trace parasitic loss [kW\sse]
        ### Power Cycle Parameters ###
        self.model.Ec = pe.Param(mutable=True, initialize=0)           #Required energy expended to start cycle [kWh\sst]
        self.model.eta_des = pe.Param(mutable=True, initialize=0)      #Cycle nominal efficiency [-] 
        self.model.etap = pe.Param(mutable=True, initialize=0)         #Slope of linear approximation of power cycle performance curve [kW\sse/kW\sst]
        self.model.Lc = pe.Param(mutable=True, initialize=0)           #Cycle heat transfer fluid pumping power per unit energy expended [kW\sse/kW\sst]
        self.model.Qb = pe.Param(mutable=True, initialize=0)           #Cycle standby thermal power consumption per period [kW\sst]
        self.model.Ql = pe.Param(mutable=True, initialize=0)           #Minimum operational thermal power input to cycle [kW\sst]
        self.model.Qu = pe.Param(mutable=True, initialize=0)           #Cycle thermal power capacity [kW\sst]
        self.model.Wb = pe.Param(mutable=True, initialize=0)           #Power cycle standby operation parasitic load [kW\sse]
        self.model.Wdotl = pe.Param(mutable=True, initialize=0)        #Minimum cycle electric power output [kW\sse]
        self.model.Wdotu = pe.Param(mutable=True, initialize=0)        #Cycle electric power rated capacity [kW\sse]
        self.model.W_delta_plus = pe.Param(mutable=True, initialize=0) #Power cycle ramp-up designed limit [kW\sse/h]
        self.model.W_delta_minus = pe.Param(mutable=True, initialize=0)#Power cycle ramp-down designed limit [kW\sse/h]
        self.model.W_v_plus = pe.Param(mutable=True, initialize=0)     #Power cycle ramp-up violation limit [kW\sse/h]
        self.model.W_v_minus = pe.Param(mutable=True, initialize=0)    #Power cycle ramp-down violation limit [kW\sse/h]
        self.model.Yu = pe.Param(mutable=True, initialize=0)           #Minimum required power cycle uptime [h]
        self.model.Yd = pe.Param(mutable=True, initialize=0)           #Minimum required power cycle downtime [h]
        ### Initial Condition Parameters ###
        self.model.s0 = pe.Param(mutable=True, initialize=0)  #Initial TES reserve quantity  [kWh\sst]
        self.model.ucsu0 = pe.Param(mutable=True, initialize=0) #Initial cycle start-up energy inventory  [kWh\sst]
        self.model.ursu0 = pe.Param(mutable=True, initialize=0) #Initial receiver start-up energy inventory [kWh\sst]
        self.model.wdot0 = pe.Param(mutable=True, initialize=0) #Initial power cycle electricity generation [kW\sse]
        self.model.yr0 = pe.Param(mutable=True, initialize=0)  #1 if receiver is generating ``usable'' thermal power initially = pe.Param(mutable=True, initialize=0) 0 otherwise  [az] this is new.
        self.model.yrsb0 = pe.Param(mutable=True, initialize=0)  #1 if receiver is in standby mode initially = pe.Param(mutable=True, initialize=0) 0 otherwise  [az] this is new.
        self.model.yrsu0 = pe.Param(mutable=True, initialize=0)  #1 if receiver is in starting up initially = pe.Param(mutable=True, initialize=0) 0 otherwise    [az] this is new.
        self.model.y0 = pe.Param(mutable=True, initialize=0)  #1 if cycle is generating electric power initially = pe.Param(mutable=True, initialize=0) 0 otherwise
        self.model.ycsb0 = pe.Param(mutable=True, initialize=0)  #1 if cycle is in standby mode initially = pe.Param(mutable=True, initialize=0) 0 otherwise
        self.model.ycsu0 = pe.Param(mutable=True, initialize=0)  #1 if cycle is in starting up initially = pe.Param(mutable=True, initialize=0) 0 otherwise    [az] this is new.
        self.model.Yu0 = pe.Param(mutable=True, initialize=0)  # duration that cycle has been generating electric power [h]
        self.model.Yd0 = pe.Param(mutable=True, initialize=0)  # duration that cycle has not been generating power (i.e., shut down or in standby mode) [h]
        ### Persistence Parameters ###
        # -------Persistence Parameters ---------
        #self.model.wdot_s_prev  = pe.Param(self.model.T, mutable=True, initialize=0)
        #self.model.wdot_s_pen  = pe.Param(self.model.T, mutable=True, initialize=0)
        
        # -------Miscellaneous Parameters taken from SAM---------
        self.model.day_of_year = pe.Param(mutable=True, initialize=0)
        self.model.disp_time_weighting = pe.Param(mutable=True, initialize=0)
        self.model.csu_cost = pe.Param(mutable=True, initialize=0)
        self.model.eta_cycle = pe.Param(mutable=True, initialize=0)
        self.model.gamma = pe.Param(mutable=True, initialize=0)
        self.model.gammac = pe.Param(mutable=True, initialize=0)
        self.model.M = pe.Param(mutable=True, initialize=0) 
        self.model.qrecmaxobs = pe.Param(mutable=True, initialize=0)
        self.model.W_dot_cycle = pe.Param(mutable=True, initialize=0)
        self.model.Z_1 = pe.Param(mutable=True, initialize=0)
        self.model.Z_2 = pe.Param(mutable=True, initialize=0)
        self.model.max_up = pe.Param(mutable=True, initialize=0)
        self.model.max_down = pe.Param(mutable=True, initialize=0)
        self.model.max_up_v = pe.Param(mutable=True, initialize=0)
        self.model.max_down_v = pe.Param(mutable=True, initialize=0)
        self.model.pen_delta_w = pe.Param(mutable=True, initialize=0)
        self.model.q0 = pe.Param(mutable=True, initialize=0)
        self.model.rsu_cost = pe.Param(mutable=True, initialize=0)
        self.model.tdown0 = pe.Param(mutable=True, initialize=0)
        self.model.tstby0 = pe.Param(mutable=True, initialize=0)
        self.model.tup0 = pe.Param(mutable=True, initialize=0)
        self.model.Wdot0 = pe.Param(mutable=True, initialize=0)
        self.model.wnet_lim_min = pe.Param(self.model.T, mutable=True, initialize=0)
        self.model.cap_frac = pe.Param(self.model.T, mutable=True, initialize=0)
        self.model.eff_frac = pe.Param(self.model.T, mutable=True, initialize=0)
        self.model.dt = pe.Param(self.model.T, mutable=True, initialize=0)
        self.model.dte = pe.Param(self.model.T, mutable=True, initialize=0)
        self.model.twt = pe.Param(self.model.T, mutable=True, initialize=0)
        
        
        #--------Parameters for the Battery---------
        
        #self.model.alpha_p = pe.Param(mutable=True, initialize=0)    #Bi-directional converter slope-intercept parameter
        #self.model.alpha_n = pe.Param(mutable=True, initialize=0)	  #Bi-directional converter slope-intercept parameter
        #self.model.beta_p = pe.Param(mutable=True, initialize=0)     #Bi-directional converter slope parameter
        #self.model.beta_n = pe.Param(mutable=True, initialize=0)	  #Bi-directional converter slope parameter
        #self.model.C_B = pe.Param(mutable=True, initialize=0)
        #self.model.C_p = pe.Param(mutable=True, initialize=0)
        #self.model.C_n = pe.Param(mutable=True, initialize=0)
        #self.model.I_upper_p{Wind} = pe.Param(mutable=True, initialize=0)
        #self.model.I_upper_n{Wind} = pe.Param(mutable=True, initialize=0)  #Battery discharge current max
        #self.model.S_B_lower = pe.Param(mutable=True, initialize=0)
        #self.model.S_B_upper = pe.Param(mutable=True, initialize=0)
        #self.model.I_lower_n = pe.Param(mutable=True, initialize=0)
        #self.model.I_lower_p = pe.Param(mutable=True, initialize=0)
        #self.model.P_B_lower = pe.Param(mutable=True, initialize=0)
        #self.model.P_B_upper = pe.Param(mutable=True, initialize=0)  #Battery min/max power rating
        #self.model.A_V = pe.Param(mutable=True, initialize=0)
        #self.model.B_V = pe.Param(mutable=True, initialize=0)	  #Battery linear voltage model slope/intercept coeffs
        #self.model.R_int = pe.Param(mutable=True, initialize=0)
        #self.model.I_avg = pe.Param(mutable=True, initialize=0)	  #Typical current expected from the battery
        #self.model.alpha_pv = pe.Param(mutable=True, initialize=0)
        #self.model.beta_pv = pe.Param(mutable=True, initialize=0)
        #self.model.Winv_lim = pe.Param(mutable=True, initialize=0)	  # Inverter max power (DC)
        #self.model.Wmax = pe.Param(mutable=True, initialize=0)	  #Constant Max power to grid
        #self.model.Winvnt = pe.Param(mutable=True, initialize=0)
        #self.model.N_csp = pe.Param(mutable=True, initialize=0)

    def generateVariables(self):
        pass 
    
    
    
if __name__ == "__main__": 
    m = RealTimeDispatchModel()